import React, { useState } from "react";

const ProductDetailsPage = ({ product }) => {
  const [quantity, setQuantity] = useState(1);

  if (!product) {
    return (
      <p className="text-center text-gray-500">
        Product details not available.
      </p>
    );
  }

  const handleQuantityChange = (e) => {
    const value = parseInt(e.target.value, 10);
    setQuantity(value > 0 ? value : 1);
  };

  return (
    <div className="bg-gray-200 font-sans min-h-screen">
      <div className="container mx-auto my-8 px-6 mt-32">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 bg-white p-6 rounded-lg shadow-md">
          {/* Product Image */}
          <div>
            <img
              src={product.productImage || "https://via.placeholder.com/300"}
              alt={product.productName}
              className="w-full h-auto rounded-lg shadow-md"
            />
          </div>

          {/* Product Details */}
          <div>
            <h2 className="text-3xl font-semibold text-gray-800 mb-4">
              {product.productName}
            </h2>
            <hr className="my-4" />

            <div className="text-gray-700">
              <p className="text-xl font-bold mb-2">
                ₹{product.discountedPrice}
              </p>
              {product.mrp && (
                <p className="line-through text-gray-500 mb-4">
                  MRP: ₹{product.mrp}
                </p>
              )}

              {/* Quantity Selector */}
              <label
                htmlFor="quantity"
                className="block text-gray-600 font-medium mb-2"
              >
                Quantity:
              </label>
              <input
                type="number"
                id="quantity"
                min="1"
                value={quantity}
                onChange={handleQuantityChange}
                className="border border-gray-300 rounded-md px-3 py-2 w-20 mb-4"
              />

              {/* Buttons */}
              <div className="flex gap-4">
                <button className="bg-green-500 text-white px-6 py-3 rounded-md hover:bg-green-600 transition duration-300 w-full">
                  Add to Cart
                </button>
                <button className="bg-gray-200 text-gray-700 px-6 py-3 rounded-md hover:bg-gray-300 transition duration-300 w-full">
                  Add to Wishlist
                </button>
              </div>
            </div>

            <hr className="my-4" />

            {/* Product Details Table */}
            <h3 className="text-2xl font-semibold text-gray-800 mb-2">
              Product Details
            </h3>
            <table className="table-auto w-full text-gray-700 mb-6 border-collapse border border-gray-300">
              <tbody>
                {[
                  [
                    "Category",
                    product.categoryName
                      ? product.categoryName.catName
                      : product.category,
                  ],
                  ["Brand", product.brand],
                  ["Weight", product.weight],
                  ["Dietary Type", product.dietaryType],
                  ["Description", product.description],
                ].map(
                  ([label, value], index) =>
                    value && (
                      <tr key={index} className="border-b border-gray-300">
                        <td className="px-4 py-2 font-medium">{label}</td>
                        <td className="px-4 py-2">{value}</td>
                      </tr>
                    )
                )}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ProductDetailsPage;





import { Router } from "express";
import authenticate from "../Middleware/auth.js";
import userCheck from "../Middleware/userCheck.js";
import Product from "../Models/product.js";
import Order from "../Models/order.js";
import Users from "../Models/user.js"

const userRoutes = Router();

userRoutes.get('/getuser', authenticate, async (req, res) => {
  try {
      // Fetch user by ID from the authenticated request
      const user = await Users.findById(req.user_id).select('-password');

      if (!user) {
          return res.status(404).json({ message: "User not found" });
      }

      res.status(200).json(user);
  } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Server error. Please try again later." });
  }
});


userRoutes.patch("/updateuser", authenticate, userCheck, async (req, res) => {
  try {
    const { fullName, phone, addresses } = req.body;

    // Find user by authenticated ID
    const user = await Users.findById(req.user_id);
    
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // Update user details if provided
    if (fullName) user.fullName = fullName;
    if (phone) user.phone = phone;
    if (addresses) user.addresses = addresses;

    await user.save();

    res.status(200).json({ message: "Profile updated successfully", user });
  } catch (error) {
    console.error("Error updating user profile:", error);
    res.status(500).json({ message: "Server error. Please try again later." });
  }
});





userRoutes.post('/addProdCart', authenticate, userCheck, async (req, res) => {
  try {
      const { productId, quantity } = req.body;
      const userId = req.user._id;

      if (!productId || quantity <= 0) {
          return res.status(400).json({ message: "Invalid product ID or quantity" });
      }

      // Check if product exists
      const product = await Product.findById(productId);
      if (!product) {
          return res.status(404).json({ message: "Product not found" });
      }

      // Check if product is in stock
      if (product.stockQty < quantity) {
          return res.status(400).json({ message: "Insufficient stock" });
      }

      // Find user and update cart
      const user = await Users.findById(userId);
      if (!user) {
          return res.status(404).json({ message: "User not found" });
      }

      // Check if product is already in the cart
      const itemIndex = user.shoppingCart.findIndex(
          (item) => item.productId.toString() === productId
      );

      if (itemIndex > -1) {
          // Update quantity if item already exists in cart
          user.shoppingCart[itemIndex].quantity += quantity;
      } else {
          // Add new product to cart
          user.shoppingCart.push({
              productId,
              quantity,
              price: product.discountedPrice
          });
      }

      await user.save();
      res.status(200).json({ message: "Product added to cart successfully", cart: user.shoppingCart });

  } catch (error) {
      console.error("Error adding product to cart:", error);
      res.status(500).json({ message: "Internal Server Error" });
  }
});


userRoutes.get('/viewCart', authenticate, userCheck, async (req, res) => {
  try {
    const userId = req.user._id;
    const cartOrder = await Order.findOne({ userId, orderId: null });
    if (!cartOrder || cartOrder.productDetails.length === 0) {
      return res.status(404).json({ message: "Your cart is empty" });
    }
    res.status(200).json(cartOrder);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Internal Server Error" });
  }
});

userRoutes.post('/checkout', authenticate, userCheck, async (req, res) => {
  try {
      const userId = req.user._id;
      const { paymentType, deliveryAddress, productDetails } = req.body;

      if (!productDetails || !Array.isArray(productDetails) || productDetails.length === 0) {
          return res.status(400).json({ message: "No products provided for checkout" });
      }

      if (!["COD", "UPI"].includes(paymentType)) {
          return res.status(400).json({ message: "Invalid payment type" });
      }

      const user = await Users.findById(userId);
      if (!user) {
          return res.status(404).json({ message: "User not found" });
      }

      if (!deliveryAddress) {
          return res.status(400).json({ message: "Delivery address is required" });
      }

      let subTotalAmt = 0;
      const detailedProducts = [];

      // Validate stock and calculate price
      for (let item of productDetails) {
          const { productId, quantity } = item;
          const product = await Product.findById(productId);

          if (!product) {
              return res.status(404).json({ message: `Product with id ${productId} not found` });
          }

          if (product.stockQty < quantity) {
              return res.status(400).json({ message: `Insufficient stock for ${product.productName}` });
          }

          subTotalAmt += product.discountedPrice * quantity;
          detailedProducts.push({ productId, quantity, price: product.discountedPrice });
      }

      // Generate unique order ID
      const orderId = `ORD-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

      // Create new order
      const newOrder = new Order({
          userId,
          orderId,
          productDetails: detailedProducts,
          paymentType,
          deliveryAddress,
          subTotalAmt,
          totalAmt: subTotalAmt
      });

      await newOrder.save();

      // Deduct stock quantity
      for (let item of productDetails) {
          await Product.findByIdAndUpdate(item.productId, { $inc: { stockQty: -item.quantity } });
      }

      // Remove ordered items from user's shopping cart
      user.shoppingCart = user.shoppingCart.filter(cartItem =>
          !productDetails.some(orderItem => orderItem.productId.toString() === cartItem.productId.toString())
      );

      await user.save();

      res.status(201).json({ message: "Order placed successfully", order: newOrder });
  } catch (error) {
      console.error("Error during checkout:", error);
      res.status(500).json({ message: "Internal Server Error" });
  }
});


userRoutes.get('/orders', authenticate, userCheck, async(req, res) => {
    try {
        const orders = await Order.find({ userId: req.user._id });
        if (!orders.length) {
            return res.status(404).json({ message: "No orders found" });
        }
        res.status(200).json(orders);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: "Internal Server Error" });
    }
});




userRoutes.put("/cart/update", authenticate, async (req, res) => {
  try {
      const userId = req.user._id; // Use authenticated user ID
      const { productId, quantity } = req.body;

      if (!productId || quantity < 1) {
          return res.status(400).json({ message: "Invalid request data. Quantity must be at least 1." });
      }

      // Validate if product exists
      const productExists = await Product.findById(productId);
      if (!productExists) {
          return res.status(404).json({ message: "Product not found." });
      }

      // Update the quantity in the shopping cart
      const updatedUser = await Users.findOneAndUpdate(
          { _id: userId, "shoppingCart.productId": productId }, 
          { $set: { "shoppingCart.$.quantity": quantity } },
          { new: true }
      ).populate("shoppingCart.productId", "productName mrp discountedPrice productImage"); // Populate product details

      if (!updatedUser) {
          return res.status(404).json({ message: "Product not found in cart." });
      }

      res.status(200).json({
          message: "Cart updated successfully.",
          cart: updatedUser.shoppingCart
      });

  } catch (error) {
      console.error("Error updating cart:", error);
      res.status(500).json({ message: "Server error. Please try again later." });
  }
});


// Remove product from cart
userRoutes.delete("/cart/remove/:productId", authenticate, async (req, res) => {
  try {
      const userId = req.user._id; // Use authenticated user ID
      const { productId } = req.params;

      // Check if the product exists in the user's cart
      const user = await Users.findOne({ _id: userId, "shoppingCart.productId": productId });
      if (!user) {
          return res.status(404).json({ message: "Product not found in cart." });
      }

      // Remove product from cart
      const updatedUser = await Users.findByIdAndUpdate(
          userId,
          { $pull: { shoppingCart: { productId } } }, // `$pull` removes the product from the array
          { new: true }
      ).populate("shoppingCart.productId", "productName mrp discountedPrice productImage"); // Populate product details

      res.status(200).json({
          message: "Product removed from cart successfully.",
          cart: updatedUser.shoppingCart
      });

  } catch (error) {
      console.error("Error removing product from cart:", error);
      res.status(500).json({ message: "Server error. Please try again later." });
  }
});



userRoutes.get("/orders", authenticate, async (req, res) => {
  try {
      const userId = req.user._id; 

      const orders = await Order.find({ userId })
          .populate("productDetails.productId", "productName brand productImage")
          .populate("deliveryAddress"); 

      res.status(200).json(orders);
  } catch (error) {
      console.error("Error fetching user orders:", error);
      res.status(500).json({ message: "Server error. Please try again later." });
  }
});


userRoutes.get("/order/:orderId", authenticate, async (req, res) => {
  try {
      const { orderId } = req.params;
      const userId = req.user._id; 

      const order = await Order.findOne({ orderId, userId }) 
          .populate("productDetails.productId", "productName brand productImage") 
          .populate("deliveryAddress");

      if (!order) {
          return res.status(404).json({ message: "Order not found or access denied." });
      }

      res.status(200).json(order);
  } catch (error) {
      console.error("Error fetching order details:", error);
      res.status(500).json({ message: "Server error. Please try again later." });
  }
});


export {userRoutes}